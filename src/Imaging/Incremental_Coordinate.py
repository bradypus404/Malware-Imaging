import sys
import math
from PIL import Image
import numpy as np
from numpy.core.fromnumeric import size
import pandas as pd

def z_score_normalize(lst):
    normalized = []
    minL = min(map(min, lst))
    maxL = max(map(max, lst))
    std = np.std(lst)
    a = 0
    for valueList in lst:
        for value in valueList:
            normalized_num = (value - minL) / (maxL - minL)
            normalized_num *= 255
            normalized.append(normalized_num)
        print(a)
        a += 1
    return normalized

hexData = []
try:
    IN = open('C:/Windows/System32/notepad.exe', 'rb') # 파일 오픈
except IOError:
    print('그런 파일이 없거나, 열기 에러입니다.')
    exit(1)
#OUT = open('binaryNotepad.txt', 'w')

#offset = 0

output = []

while True:
    buf16 = IN.read(16)
    buf16Len = len(buf16)
    if(buf16Len == 0):break

    for i in range(buf16Len): # 헥사 부분의 헥사 값 16개 출력 (8개씩 2부분으로)
        output.append(int(buf16[i]))

if len(output) % 2 == 1:
    output = np.pad(output, (0, 1), mode='constant', constant_values=0)

outputDuble = np.reshape(output,(int(len(output)/2), 2))

imageIC = [[255 for j in range(256)] for i in range(256)]

for x, y in outputDuble:
    imageIC[x][y] -= 1
    if imageIC[x][y] <= 0:
        imageIC[x][y] = 0

imageIC = z_score_normalize(imageIC)

imageG = np.reshape(imageIC,(256, 256))
print(imageG)

print(np.shape(imageG))
print(type(imageG))

image = Image.fromarray(np.uint8(imageG))
img = Image.new(mode='L', size=(256, 256))
image.save('notepad.png')
image.show()


IN.close()

'''
image = Image.fromarray(imageG)
img = Image.new(mode='L', size=(256, 256))
img.save('notepad.JPEG', format='JPEG')
img.show()
'''

'''
import sys
import math
from PIL import Image, ImageMath
import numpy as np
from numpy.core.fromnumeric import size
import pandas as pd
"""
def z_score_normalize(lst):
    normalized = []
    minL = min(map(min, lst))
    maxL = max(map(max, lst))
    std = np.std(lst)
    a = 0
    for valueList in lst:
        for value in valueList:
            normalized_num = (value - minL) / (maxL - minL)
            normalized_num *= 255
            normalized.append(normalized_num)
        print(a)
        a += 1
    return normalized
"""
def z_score_normalize(lst):
    normalized = []
    Qmax =  255
    Qmin = 0
    minL = min(map(min, lst))
    maxL = max(map(max, lst))
    std = np.std(lst)
    a = 0
    for valueList in lst:
        for value in valueList:
            
            scale_factor = (maxL - minL) / (Qmax - Qmin)
            zero_point = Qmin - round(minL/scale_factor)
            
            normalized_num = (value/scale_factor)+zero_point
            normalized.append(normalized_num)
            #print(value)
        print(a)
        a += 1
    return normalized

hexData = []
try:
    IN = open('C:/Windows/System32/notepad.exe', 'rb') # 파일 오픈
except IOError:
    print('그런 파일이 없거나, 열기 에러입니다.')
    exit(1)
#OUT = open('binaryNotepad.txt', 'w')

#offset = 0

output = []

while True:
    buf16 = IN.read(16)
    buf16Len = len(buf16)
    if(buf16Len == 0):break

    #output = "%08X:  " % (offset) # Offset(번지)을, 출력 버퍼에 쓰기

    for i in range(buf16Len): # 헥사 부분의 헥사 값 16개 출력 (8개씩 2부분으로)
        #if (i == 2): output += " " # 8개씩 분리
        #output += "%02X " % (int(buf16[i])) # 헥사 값 출력
        output.append(int(buf16[i]))

    #offset += 16
    #OUT.write(output)

if len(output) % 2 == 1:
    output = np.pad(output, (0, 1), mode='constant', constant_values=0)

outputDuble = np.reshape(output,(int(len(output)/2), 2))
#print(outputDuble)

imageIC = [[255 for j in range(256)] for i in range(256)]

for x, y in outputDuble:
    imageIC[x][y] -= 1
    if imageIC[x][y] <= 0:
        imageIC[x][y] = 0

imageIC = z_score_normalize(imageIC)

imageG = np.reshape(imageIC,(256, 256))
print(imageG)

print(np.shape(imageG))
print(type(imageG))
#for x, y in outputDuble:

image = Image.fromarray(np.uint8(imageG))
img = Image.new(mode='L', size=(256, 256))
image.save('notepad.png')
image.show()

IN.close()
'''